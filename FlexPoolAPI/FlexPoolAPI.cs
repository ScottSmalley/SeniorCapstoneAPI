/*
 * Utah Valley University
 * CS4550 Capstone Project
 * FlexPool Project Full Team:
 * Front End: Brandon Bezzant
 * Front End: Mike Daniel
 * Backend (meaning these project files): Scott Smalley
 * 
 * Summary:
 * This API uses the Command design pattern
 * to focus on each command or "action" item sent
 * by the user. We take in a request that contains 
 * a body with JSON data. We deserialize it, convert 
 * it to a Dictionary, and determine which type of 
 * command to execute based on that data. We execute 
 * the appropriate command and package it up to be 
 * sent back in a JSON format.
 * 
 * - Designed and coded by Scott Smalley.
 *   scottsmalley90@gmail.com
 */
using System;
using Newtonsoft.Json;
using Amazon.Lambda.Core;
using Amazon.Lambda.APIGatewayEvents;
using System.Collections.Generic;
using System.Net;
using FlexPoolAPI.Model;

// https://aws.amazon.com/premiumsupport/knowledge-center/build-lambda-deployment-dotnet/ 
// $> dotnet lambda deploy-function --region us-east-2 --function-name flexpooldb
//
// Assembly attribute to enable the Lambda function's JSON input to be converted into a .NET class.
[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.Json.JsonSerializer))]
namespace FlexPoolAPI
{
    public class FlexPoolAPI
    {
        //Toggles whether informational console output is used or not.
        bool inDevMode = true;
        /// <summary>
        /// Takes in the APIGatewayProxyRequest, determines
        /// what command is requested, executes the command,
        /// and returns the serialized data in an 
        /// APIGatewayProxyResponse.
        /// </summary>
        /// <param name="apiGatewayRequest"></param>
        /// <returns></returns>
        public APIGatewayProxyResponse Handler(APIGatewayProxyRequest apiGatewayRequest, ILambdaContext lambdaContextnotepad)
        {
            if (inDevMode)
            {
                Console.WriteLine(apiGatewayRequest.Path + "\n" + apiGatewayRequest.HttpMethod + "\n" + apiGatewayRequest.Body);
            }

            //Initializing the response object sent back to the user.
            APIGatewayProxyResponse response = new APIGatewayProxyResponse()
            {
                StatusCode = (int)(HttpStatusCode.NoContent),
                Body = string.Empty
            };

            //New-up Action objects and executes.
            //Get the mysql database connection from the Environment Variables supplied by AWS Lambda.
            try
            {
                //DB Connection
                string mySQLConnectionString = Environment.GetEnvironmentVariable("MYSQL_CONN");

                //Deserialize the JSON object sent by the user.
                Dictionary<string, string[]> requestBody = JsonConvert.DeserializeObject<Dictionary<string, string[]>>(apiGatewayRequest.Body);

                //Create an Action item that is used to get/set data for the Command Objects.
                Model.Action newAction = new Model.Action(requestBody, mySQLConnectionString);

                //Parser to determine which Command Object to use and execute.
                ActionParser parse = new ActionParser();

                //Instantiation of the appropriate Command Object generated by the parser.
                ActionCommand action = parse.DetermineCommandType(newAction);

                //Executes the Command Object.
                ActionExecutor executor = new ActionExecutor();

                //Have the Executor execute on the Command Object, and store the resulting data in a Dictionary<string,string[]>.
                Dictionary<string, string[]> responseData = executor.ExecuteCommand(action);

                //Serialize the data to be returned to the user.
                response.Body = JsonConvert.SerializeObject(responseData);

                //Give an OK status code, and add some headers that will allow the return trip
                //back to the user.
                response.StatusCode = (int)(HttpStatusCode.OK);
                response.Headers = new Dictionary<string, string> { { "Content-Type", "text/json" } };
                response.Headers.Add("Access-Control-Allow-Origin", "*");
                response.Headers.Add("Access-Control-Allow-Credentials", "true");
                response.Headers.Add("Access-Control-Allow-Methods", "GET, POST, DELETE");
                response.Headers.Add("Access-Control-Allow-Headers", "Content-Type");

            }
            catch (ArgumentOutOfRangeException argOutExcep)
            {
                //Timeout exceeded before the response returned.
                Console.WriteLine(argOutExcep.Message);
                Console.WriteLine(argOutExcep.StackTrace);
                response.StatusCode = (int)(HttpStatusCode.RequestTimeout);
            }
            catch (Exception ex)
            {
                //Timeout exceeded before the response returned.
                Console.WriteLine(ex.Message);
                Console.WriteLine(ex.StackTrace);
                response.StatusCode = (int)(HttpStatusCode.InternalServerError);
            }

            if (inDevMode)
            {
                Console.WriteLine(response.StatusCode + '\n' + response.Body);
            }
            return response;
        }
    }
}
